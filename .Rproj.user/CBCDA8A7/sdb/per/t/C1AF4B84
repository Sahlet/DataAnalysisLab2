{
    "collab_server" : "",
    "contents" : "library(shiny)\nlibrary(moments)\n\nprimary_statistical_analysis <- function(vec, confidence_level = 0.95) {\n  size_vec <- length(vec);\n  t_quantile <- qt((1 + confidence_level) / 2, size_vec - 1);\n  \n  mean_vec <- mean(vec);\n  sd_vec <- sd(vec);\n  #asymmetry\n  skewness_vec <- skewness(vec);\n  #excess\n  kurtosis_vec <- kurtosis(vec);\n  \n  mean_deviation <- t_quantile*sd_vec/sqrt(size_vec);\n  sd_deviation <- t_quantile*sd_vec/sqrt(2*size_vec);\n  skewness_deviation <- t_quantile*sqrt(6*(size_vec - 2)/((size_vec + 1)*(size_vec + 3)));\n  kurtosis_deviation <-\n    t_quantile*sqrt(\n      24*size_vec*(size_vec - 2)*(size_vec - 3)\n      /\n      (((size_vec + 1)^2)*(size_vec + 3)*(size_vec + 5))\n    );\n  \n  return(c(\n    as.character(mean_vec),\n    paste0(\"(\", mean_vec - mean_deviation, \", \", mean_vec + mean_deviation, \")\"),\n    as.character(sd_vec),\n    paste0(\"(\", sd_vec - sd_deviation, \", \", sd_vec + sd_deviation, \")\", sep = \"\"),\n    as.character(skewness_vec),\n    paste0(\"(\", skewness_vec - skewness_deviation, \", \", skewness_vec + skewness_deviation, \")\", sep = \"\"),\n    as.character(kurtosis_vec),\n    paste0(\"(\", kurtosis_vec - kurtosis_deviation, \", \", kurtosis_vec + kurtosis_deviation, \")\", sep = \"\")\n  ));\n}\n\ncorrelation_ratio_test <- function(my_table, points_from_range_, confidence_level = 0.95) {\n  my_table_x_range <- range(my_table[[1]]);\n  points_from_range <- sort(split(points_from_range_, sapply(points_from_range_, function(arg) {\n    if (arg >= my_table_x_range[1] && arg <= my_table_x_range[2]){\n      return (1);\n    }\n    return(0);\n  }))$'1');\n  \n  if (points_from_range[1] != my_table_x_range[1]) points_from_range <- c(my_table_x_range[1], points_from_range);\n  points_from_range_length <- length(points_from_range);\n  if (points_from_range[points_from_range_length] != my_table_x_range[2]) {\n    points_from_range <- c(points_from_range, my_table_x_range[2]);\n    points_from_range_length <- points_from_range_length + 1;\n  }\n  \n  ranges <- matrix(nrow = points_from_range_length - 1, ncol = 2);\n  \n  for(n in 1:(points_from_range_length - 1)) {\n    ranges[n,] <- c(points_from_range[n], points_from_range[n + 1]);\n  }\n  \n  my_table_length <- length(my_table[[1]]);\n  ranges_length <- points_from_range_length - 1;\n  range_numbers <- array(dim = my_table_length);\n  \n  n <- 1;\n  while (n <= my_table_length) {\n    if (is.na(my_table[n, 1])){\n      range_numbers[n] <- NA;\n      n <- n + 1;\n      next;\n    }\n    range_number <- 1;\n    while(range_number <= (ranges_length - 1)){\n      if (\n          (ranges[range_number, 1] <= my_table[n, 1]) &&\n          (my_table[n, 1] < ranges[range_number, 2])\n        ){\n        break;\n      }\n      range_number <- range_number + 1;\n    }\n    range_numbers[n] <- range_number;\n    n <- n + 1;\n  }\n  \n  averages <- tapply(1:my_table_length, range_numbers, function(my_table_part) {\n    mean(my_table[[2]][my_table_part]);\n  });\n  \n  ratio <- (\n    sd(sapply(range_numbers, function(range_number){\n      averages[as.character(range_number)];\n    }))\n    /\n    sd(my_table[[2]])\n  )^2;\n  \n  result <- list();\n  \n  result$data.description <- paste(\"data: \", colnames(my_table)[1], \"and\", colnames(my_table)[2]);\n  \n  df1 <- ranges_length - 1;\n  df2 <- my_table_length - ranges_length;\n  \n  result$test.f <- (ratio/df1)/((1 - ratio)/df2);\n  result$test.df1 <- df1;\n  result$test.df2 <- df2;\n  result$test.f_quantile <- qf(confidence_level, df1, df2);\n  result$test.p_val <- 1 - pf(result$test.f, df1, df2);\n  \n  if (result$test.f <= result$test.f_quantile) {#H0\n    result$hypothesis.main <- TRUE;\n    result$hypothesis.alternative <- FALSE;\n    result$hypothesis.description <- \"main hypothesis: true ratio is equal to 0\";\n  } else {#H1\n    result$hypothesis.main <- FALSE;\n    result$hypothesis.alternative <- TRUE;\n    result$hypothesis.description <- \"alternative hypothesis: true ratio is not equal to 0\";\n  }\n  \n  result$conf.description <- paste(result$conf.level, \"percent confidence interval:\", result$conf.int);\n  \n  result$ratio.estimate <- ratio;\n  result$ratio.description <- paste(\"ratio estimate:\", result$ratio.estimate);\n  \n  return (result);\n};\n\n\nshinyServer(function(input, output) {\n  \n  # By declaring get_my_table as a reactive expression we ensure \n  # that:\n  #\n  #  1) It is only called when the inputs it depends on changes\n  #  2) The computation and result are shared by all the callers \n  #\t  (it only executes a single time)\n  #\n  get_my_table <- reactive({\n    result <- NULL;\n    if (!is.null(input$file1) && !is.null(input$file1$datapath)){\n      result <- read.table(input$file1$datapath, header=input$header, sep=input$sep);\n      if (!input$header) {\n        colnames(result) <- c('x', 'y');\n      }\n    }\n    return(result);\n  });\n   \n  #* **1.**\tПобудову кореляційного поля\n  output$correlation_field <- renderPlot({\n    my_table <- get_my_table();\n    if (!is.null(my_table)) {\n      lm_ <- lm(my_table[[2]] ~ my_table[[1]]);\n      \n      pl_ <- plot(my_table);\n      grid();\n      abline(lm_, col = \"red\");\n      \n      #y = 1/(k*x + b)\n      lm_ <- lm(1/my_table[[2]] ~ my_table[[1]]);\n      x_min_max <- range(my_table[[1]]);\n      x <- seq(x_min_max[1], x_min_max[2], 0.1);\n      y <- 1/(lm_$coefficients[1] + lm_$coefficients[2]*x);\n      lines(x, y, col = \"blue\");\n      \n      return(pl_);\n    }\n    return(NULL);\n  });\n  \n  output$sample_size <- renderPrint({\n    my_table <- get_my_table();\n    if (!is.null(my_table)){\n      return(cat(paste(\"sample size is\", length(my_table[[1]]))));\n    }\n    return(NULL);\n  });\n  \n  #і проведення первинного статистичного аналізу окремих ознак об’єкта (точкове та інтервальне оцінювання середнього, середньоквадратичного, коефіцієнтів асиметрії та ексцесу).\n  output$primary_statistical_analysis <- renderTable({\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    row_names <- c(\n      \"mean\",\n      \"mean conf.int\",\n      \"sd (standard deviation)\",\n      \"sd conf.int\",\n      \"asymmetry\",\n      \"asymmetry conf.int\",\n      \"excess\",\n      \"excess conf.int\"\n    );\n    \n    #cat(\"sample size is\", length(my_table[[1]]), \"\\n\\n\");\n    \n    result <- data.frame(\n      row_names,\n      primary_statistical_analysis(my_table[[1]], input$confidence_level),\n      primary_statistical_analysis(my_table[[2]], input$confidence_level)\n    );\n    colnames(result) <- c(\"\", colnames(my_table));\n    return (result);\n  });\n  \n  #* 2.1.\tзнаходження оцінки коефіцієнта кореляції, перевірку його значущості та призначення довірчого інтервалу (у випадку значущості);\n  #* 2.3.\tпідрахунок рангових коефіцієнтів кореляції Спірмена та Кендалла та перевірку їх значущості.\n  output$correlation_test <- renderTable({\n    #Pearson_correlation_test\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    #Pearson correlation test\n    cor_test <- cor.test(my_table[[1]], my_table[[2]], conf.level = input$confidence_level, method = \"pearson\");\n    #cor_test$data.name <- paste(colnames(my_table)[1], \"and\", colnames(my_table)[2]);\n    ratio_test <- NULL;\n    \n    if (!is.null(my_table) && !is.null(input$set_own_subranges)) {\n    \n      subranges <- c();\n      \n      call_correlation_ratio_test <- TRUE;\n       \n      if (!input$set_own_subranges) {\n        my_table_x_range <- range(my_table[[1]]);\n        if (input$subrange_number <= 1) {\n          subranges <- my_table_x_range;\n        } else {\n          range_length = (my_table_x_range[2] - my_table_x_range[1]) / input$subrange_number;\n          for (n in 0:(input$subrange_number - 1)){\n            subranges <- c(subranges, my_table_x_range[1] + n*range_length);\n          }\n          subranges <- c(subranges, my_table_x_range[2]);\n        }\n      } else {\n        if (!is.null(input$file2_ranges) && !is.null(input$file2_ranges$datapath)){\n          subranges <- read.table(input$file2_ranges$datapath, header=FALSE, sep='')[[1]];\n        } else {\n          call_correlation_ratio_test <- FALSE;\n        }\n      }\n      \n      if (call_correlation_ratio_test)\n        ratio_test <- correlation_ratio_test(my_table, subranges, input$confidence_level);\n    }\n    \n    #Spearman correlation test\n    Sp_cor_test <- cor.test(my_table[[1]], my_table[[2]], conf.level = input$confidence_level, method = \"spearman\");\n    \n    #Kendall correlation test\n    Kend_cor_test <- cor.test(my_table[[1]], my_table[[2]], conf.level = input$confidence_level, method = \"kendall\");\n    \n    null_rm <- function(val){\n      if (is.null(val)) return(\"-\");\n      return(val);\n    }\n    \n    row_names <- c(\n      \"Pearson's\",\n      \"corr ratio\",\n      \"Spearman's\",\n      \"Kendall's\"\n    );\n    \n    estimate <- c(\n      cor_test$estimate,\n      null_rm(ratio_test$ratio.estimate),\n      Sp_cor_test$estimate,\n      Kend_cor_test$estimate\n    );\n    \n    statistic <- c(\n      cor_test$statistic,\n      null_rm(ratio_test$test.f),\n      Sp_cor_test$statistic,\n      Kend_cor_test$statistic\n    );\n    \n    quantile <- c(\n      qt((1 + input$confidence_level)/2, length(my_table[[1]]) - 2),\n      null_rm(ratio_test$test.f_quantile),\n      qt((1 + input$confidence_level)/2, length(my_table[[1]]) - 2),\n      qnorm((1 + input$confidence_level)/2)\n    );\n    \n    H0_estimate_equal_to_0 <- abs(statistic) <= quantile;\n    \n    p_level <- c(\n      cor_test$p.value,\n      null_rm(ratio_test$test.p_val),\n      Sp_cor_test$p.value,\n      Kend_cor_test$p.value\n    );\n    conf_int <- c(\n      paste0(\"(\", cor_test$conf.int[1], \"; \", cor_test$conf.int[2], \")\"),\n      \"-\",\n      \"-\",\n      \"-\"\n    );\n    \n    result <- data.frame(\n      row_names,\n      estimate,\n      statistic,\n      quantile,\n      H0_estimate_equal_to_0,\n      p_level,\n      conf_int\n    );\n    \n    colnames(result)[1] <- \"\";\n    colnames(result)[5] <- \"H0: estimate is 0\";\n    \n    return (result);\n    \n  });\n  \n  #* 2.2.\tобчислення коефіцієнта кореляційного відношення та перевірку його значущості;\n  output$min_max <- renderPrint({\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    \n    return(cat(\n      paste0(\"[min(\", colnames(my_table)[1], \"); max(\", colnames(my_table)[1], \")]   =   [\", min(my_table[[1]]), \"; \", max(my_table[[1]]), \"]\")\n    ));\n  });\n  \n  output$select_file_text <- renderPrint({\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    \n    return(cat(\n      paste0(\"Select file with vector of numbers from range [\", min(my_table[[1]]), \"; \", max(my_table[[1]]), \"]\")\n    ));\n  });\n  \n  output$lin_regression <- renderTable({\n    lm_ <- lm(my_table[[2]] ~ my_table[[1]])\n    summ <- summary(lm_);\n    #summ$coefficients; is: Estimate, Std.Error of estimate (for conf.int),  t_statistic, p_level\n  });\n  \n})\n",
    "created" : 1481006344467.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "3|72|34|0|\n36|91|124|0|\n136|28|145|2|\n169|37|175|2|\n178|54|201|2|\n",
    "hash" : "1879156920",
    "id" : "C1AF4B84",
    "lastKnownWriteTime" : 1481468270,
    "last_content_update" : 1481468271041,
    "path" : "D:/Книги/Прога/7 семестр/Випадкові процеси/DataAnalysisLab2/server.R",
    "project_path" : "server.R",
    "properties" : {
        "docOutlineSize" : "72.9956574312099",
        "docOutlineVisible" : "0"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}